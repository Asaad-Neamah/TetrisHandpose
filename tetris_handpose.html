<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Tetris with TensorFlow.js (One Move Per Zone)</title>
  <style>
    body {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      font-family: sans-serif;
      margin: 20px;
    }
    #game-container {
      margin-right: 20px;
    }
    canvas {
      background: #000;
      border: 1px solid #333;
      display: block;
    }
    #video {
      transform: scaleX(-1); /* Mirror the camera for a more natural feel */
    }
    .info {
      max-width: 400px;
    }
    .controls {
      margin-top: 10px;
    }
  </style>
</head>
<body>

<div id="game-container">
  <h2>Tetris (One Move Per Hand Zone)</h2>
  <canvas id="tetris" width="240" height="480"></canvas>

  <div class="controls">
    <label for="speedRange">Game Speed (ms/drop):</label>
    <input
      type="range"
      id="speedRange"
      min="100"   <!-- 100ms is very fast -->
      max="2000"  <!-- 2000ms is quite slow -->
      value="1000"
      step="100"
    />
    <span id="speedDisplay">1000 ms</span>
  </div>
</div>

<div>
  <h2>Camera View</h2>
  <video id="video" width="320" height="240" autoplay playsinline></video>
  <div class="info">
    <p><strong>Zones (one move per entry):</strong></p>
    <ul>
      <li><strong>Left side</strong> → Move Tetris block left</li>
      <li><strong>Right side</strong> → Move Tetris block right</li>
      <li><strong>Top</strong> → Rotate block</li>
      <li><strong>Bottom</strong> → Drop block</li>
      <li><strong>Center</strong> → No action</li>
    </ul>
    <p>
      This demo uses <a href="https://github.com/tensorflow/tfjs-models/tree/master/handpose" target="_blank">Handpose</a> to
      detect the hand’s position. Each time your hand enters a new zone, exactly one move is triggered.
    </p>
  </div>
</div>

<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<!-- Handpose model -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.js"></script>

<script>
/**************************************************************
 * 1. Tetris Game Logic
 **************************************************************/
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');

const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 24; // each block is 24px

// Create a 2D board array, filled with 0 (empty)
let board = [];
for (let r = 0; r < ROWS; r++) {
  board[r] = [];
  for (let c = 0; c < COLS; c++) {
    board[r][c] = 0;
  }
}

// Define Tetris shapes (tetrominoes)
const SHAPES = {
  I: [[1,1,1,1]],
  O: [[2,2],
      [2,2]],
  T: [[0,3,0],
      [3,3,3]],
  S: [[0,4,4],
      [4,4,0]],
  Z: [[5,5,0],
      [0,5,5]],
  J: [[6,0,0],
      [6,6,6]],
  L: [[0,0,7],
      [7,7,7]],
};

// All shape keys for random selection
const SHAPE_KEYS = Object.keys(SHAPES);

// Current piece + position
let currentPiece = null;
let currentX = 0;
let currentY = 0;

// Spawn a random piece
function spawnNewPiece() {
  const shapeKey = SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)];
  // Make a deep copy of the shape array
  currentPiece = SHAPES[shapeKey].map(row => row.slice());
  currentX = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
  currentY = 0;
  
  // If collision right away -> Game Over (simple reset)
  if (collision()) {
    resetBoard();
  }
}

// Check collision with board or boundaries
function collision(offsetX = 0, offsetY = 0, piece = currentPiece) {
  const futureX = currentX + offsetX;
  const futureY = currentY + offsetY;
  
  for (let r = 0; r < piece.length; r++) {
    for (let c = 0; c < piece[r].length; c++) {
      if (piece[r][c]) {
        const newX = futureX + c;
        const newY = futureY + r;
        // Check walls or bottom
        if (newX < 0 || newX >= COLS || newY >= ROWS) {
          return true;
        }
        // Check if space is occupied
        if (newY >= 0 && board[newY][newX] !== 0) {
          return true;
        }
      }
    }
  }
  return false;
}

// Merge current piece into board
function mergePiece() {
  for (let r = 0; r < currentPiece.length; r++) {
    for (let c = 0; c < currentPiece[r].length; c++) {
      if (currentPiece[r][c]) {
        board[currentY + r][currentX + c] = currentPiece[r][c];
      }
    }
  }
}

// Clear full lines
function clearLines() {
  for (let r = ROWS - 1; r >= 0; r--) {
    let isFull = true;
    for (let c = 0; c < COLS; c++) {
      if (board[r][c] === 0) {
        isFull = false;
        break;
      }
    }
    if (isFull) {
      board.splice(r, 1);
      board.unshift(new Array(COLS).fill(0));
      r++; // re-check same row index
    }
  }
}

// Rotate piece (90 deg clockwise)
function rotatePiece() {
  if (!currentPiece) return;
  // Transpose + reverse each row
  const rotated = [];
  for (let c = 0; c < currentPiece[0].length; c++) {
    const row = [];
    for (let r = currentPiece.length - 1; r >= 0; r--) {
      row.push(currentPiece[r][c]);
    }
    rotated.push(row);
  }
  // Only apply if no collision
  if (!collision(0, 0, rotated)) {
    currentPiece = rotated;
  }
}

// Reset the board (simple "restart")
function resetBoard() {
  for (let r = 0; r < ROWS; r++) {
    board[r].fill(0);
  }
  spawnNewPiece();
}

// Helper to draw a single square block
function drawBlock(x, y, val) {
  ctx.fillStyle = getColor(val);
  ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  ctx.strokeStyle = '#222';
  ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
}

// Just pick a color based on shape ID (1-7)
function getColor(val) {
  const colors = [
    '#000', // 0
    '#f00', // 1: I
    '#0f0', // 2: O
    '#00f', // 3: T
    '#ff0', // 4: S
    '#0ff', // 5: Z
    '#f0f', // 6: J
    '#f90', // 7: L
  ];
  return colors[val] || '#fff';
}

// Draw board + current piece
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw board
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c] !== 0) {
        drawBlock(c, r, board[r][c]);
      }
    }
  }
  
  // Draw current piece
  if (currentPiece) {
    for (let r = 0; r < currentPiece.length; r++) {
      for (let c = 0; c < currentPiece[r].length; c++) {
        if (currentPiece[r][c] !== 0) {
          drawBlock(currentX + c, currentY + r, currentPiece[r][c]);
        }
      }
    }
  }
}

/**************************************************************
 * 2. Time-Based Tetris Update (Speed Control)
 **************************************************************/
let lastTime = 0;
let dropCounter = 0;
let dropInterval = 1000; // default speed: 1000 ms per row

function update(time = 0) {
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  
  // If it's time to drop the piece
  if (dropCounter > dropInterval) {
    if (!collision(0,1)) {
      currentY++;
    } else {
      mergePiece();
      clearLines();
      spawnNewPiece();
    }
    dropCounter = 0;
  }
  
  draw();
  requestAnimationFrame(update);
}

// Start the Tetris loop
resetBoard();
requestAnimationFrame(update);

// Listen for speed changes via slider
const speedRange = document.getElementById('speedRange');
const speedDisplay = document.getElementById('speedDisplay');

speedRange.addEventListener('input', () => {
  dropInterval = Number(speedRange.value);
  speedDisplay.textContent = `${dropInterval} ms`;
});

/**************************************************************
 * 3. Handpose Model (TensorFlow.js) and One-Move-Per-Zone Logic
 **************************************************************/
const video = document.getElementById('video');
let model = null;
let lastZone = null; // tracks the last zone we recognized

// Request camera
async function initCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;
  return new Promise((resolve) => {
    video.onloadedmetadata = () => resolve(video);
  });
}

// Load Handpose model
async function loadModel() {
  model = await handpose.load();
  console.log('Handpose model loaded.');
}

// We will classify the "zone" of the hand as: left, right, top, bottom, or center
function getZone(avgX, avgY, vw, vh) {
  if (avgX < 0.3 * vw)  return 'left';
  if (avgX > 0.7 * vw)  return 'right';
  if (avgY < 0.3 * vh)  return 'top';
  if (avgY > 0.7 * vh)  return 'bottom';
  return 'center';
}

// Run gesture detection ~10 times/sec
setInterval(detectGesture, 100);

async function detectGesture() {
  if (!model) return;
  
  const predictions = await model.estimateHands(video);
  if (predictions.length > 0) {
    // Take the first hand’s keypoints
    const keypoints = predictions[0].landmarks;
    let sumX = 0, sumY = 0;
    keypoints.forEach(kp => {
      sumX += kp[0];
      sumY += kp[1];
    });
    const avgX = sumX / keypoints.length;
    const avgY = sumY / keypoints.length;
    
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    
    // Determine the current zone
    const zone = getZone(avgX, avgY, vw, vh);
    
    // Only trigger an action if we've changed zones
    if (zone !== lastZone) {
      if (zone === 'left') moveLeft();
      else if (zone === 'right') moveRight();
      else if (zone === 'top') rotatePiece();
      else if (zone === 'bottom') dropPiece();
      
      // Update lastZone
      lastZone = zone;
    }
  } else {
    // If no hand detected, reset zone to null
    lastZone = null;
  }
}

/**************************************************************
 * 4. Helper Tetris Moves for Gestures
 **************************************************************/
function moveLeft() {
  if (currentPiece && !collision(-1, 0)) {
    currentX--;
    draw();
  }
}

function moveRight() {
  if (currentPiece && !collision(1, 0)) {
    currentX++;
    draw();
  }
}

function dropPiece() {
  if (!currentPiece) return;
  while (!collision(0, 1)) {
    currentY++;
  }
  mergePiece();
  clearLines();
  spawnNewPiece();
  draw();
}

/**************************************************************
 * 5. Initialization (Camera + Model)
 **************************************************************/
(async function(){
  await initCamera();
  await loadModel();
  console.log('Camera & Model ready. Tetris is running...');
})();
</script>
</body>
</html>
